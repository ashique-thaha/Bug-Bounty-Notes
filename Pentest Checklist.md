#### Access Control 

- [ ] use normal account and go through functionalities, capture requests using Burp.
- [ ] check for  responses that contains changeable ids or some thing like that. eg: if `user_id=1` is present in response try to add this in another request with modification  within json data in repeater.
#### XSS(cross site scripting)
- [ ] look for opportunities to submit user input (search box, parameters etc).

- [ ] look for places where input get stored like comment fields, user profile etc.

- [ ] look for dropdown menus, if they exist use proxy and see if we can insert payload from there.

- [ ] if frame work is angular check ng-app on source code, if so search ng-app xss payload

- [ ] 

#### Open Redirect

- [ ] search for the parameters used for redirects, ex: `next, u, n, forward, RelayState `etc.
- [ ] use google dorking to find specific parameters ex: `inurl:=http site:example.com` , `inurl:redir site:example.com`
- [ ] Check for javascript attributes on `<a>` tags. 

#### CSRF

- [ ] look for state changing requests like activities that modify user settings, sending tweets etc.

- [ ] Go through each endpoints and access every functionality to find state changing requests and sort them to test later example:
- `Change password: email.example.com/password_change`
- `POST request`
- `Request parameters: new_password`

- [ ] look through these filtered endpoints and see if any have `csrf` protections like, `csrf token` , `same site flag` in cookie etc

- [ ] See if changing the http method bypass` csrf `protection. example, change post method to get and use the same parameter in body to url with our own value.

- [ ] Try changing the `csrf` token to blank or deleting the `csrf token parameter` itself. 

- [ ] Now create a test account on the target and use `csrf token` obtained for that account to impersonate victim.

- [ ] To bypass `double-submit csrf tokens` , most probably the value in the post parameter request body and cookie only needs to be the same. ie, server may not be validating the validity of the token.

- [ ] The application might be validating the `referrer header` to verify that, the request came from an allowed list of domains. therefore removing referrer header might help. also try any allowed list of domain in referrer header. ex: `Referer: example.com.attacker.com` , `Referer: attacker.com/example.com`

- [ ] Also try to find any `XSS` that can be used to steal `csrf tokens`.

- [ ] Try to make `csrf` more impactful by, proving a chance of sensitive information leak or something like that.

- [ ] we can make self XSS stored XSS using `csrf` by impersonating as the user and accessing and storing payload on vulnerable element.

#### IDOR

- [ ] Do a source code review to find which all direct object references are protected by access control.

- [ ] create two different accounts for each level of privilege, eg: two user accounts , two admin accounts and so on. This will help in testing on different levels.

- [ ]  look for any object references. ex:file names, user id etc, to test.

- [ ] if the reference is a random long number, then look if it is encoded and try to decode.

- [ ] look for object reference in comment sections and try to use it.


#### SQLi

- [ ] insert an apostrophe wherever possible and look for anomalies, if any changes occur we can confirm that SQLi has scope.
- [ ] Instead of trying each and every payload use `SECLIST`'s sql injection payload and brute force it use burp.

#### SSRF

- [ ] Review the application's source code and check whether if the application validates every urls the user is giving to them.

- [ ] Look for features where the application needs fetch external resources.

- [ ] Look for `webhook urls`.

- [ ] If an endpoint is found try testing with IPv6 address that focus to local network eg: `::l` ,`fc00::`

- [ ] Confuse the server by getting your own domain name pointed to local address and enter the address in the endpoint.

- [ ] In the case of a blind SSRF, check if the server behaviour differs when you request different hosts or ports

- [ ] use bypass like: 
```
https://expected-host:fakepassword@evil-host
```
```
https://evil-host#expected-host
```
```
https://expected-host.evil-host
```

#### XXEs

- [ ] Look for XML used endpoints.

- [ ] Try forcing the application to parse XML by changing the content type header and explicitly entering XML

- [ ] try to retrieve files with XXE refer to web security notes

- [ ] leverage `xxe` to `ssrf`

- [ ] check xml via Xinclude

- [ ] try xml via image upload eg: svg


#### Payment Gateway

- [ ] Try quantity tampering of parameters.

- [ ] Try to work http parameter pollution by passing a valid parameter multiple times.

- [ ] If there is a donation(charity) value parameter then try to bring it negative this might tamper the overall price.

- [ ] If the price and other details are send to a third party payment gateway, using post request  there is a chance to intercept the post form using proxy and modify the values.

- [ ] if the payment gateway use iframe, there might be a chance to tamper with the parameter on the iframe url.

- [ ] Try to make unencrypted request explicitly if the payment gateway uses encrypted communication.(This will be successful unless it is specifically configured to reject them)

#### Command injection
- [ ] First look for functions that can execute commands on back-end
- [ ] Try URL/system/{command} 


#### Authentication
- [ ] Look for login endpoints( based on tech stack too ), separate them into:
 => Authenticated
 => Unauthenticated 
 => Default credentials 

#### Comment feature
- [ ] check for comment functions on web app and sort them in mind map
- [ ] check if the comment have any id. If so, try change it and see if any IDOR is present  or delete comments and look if deleted comments are still in response(usually json).



#### Web Service attack
- [ ] Look for WSDL file on the web app
- [ ] Try  `curl http://<TARGET IP>:3002/wsdl?wsdl`
- [ ] Try SOAPAction spoofing
- [ ] create python script to do this, here in this 

ex: I am using command injection.
```python
import requests

while True:
    cmd = input("$ ")
    payload = f'<?xml version="1.0" encoding="utf-8"?><soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  xmlns:tns="http://tempuri.org/" xmlns:tm="http://microsoft.com/wsdl/mime/textMatching/"><soap:Body><LoginRequest xmlns="http://tempuri.org/"><cmd>{cmd}</cmd></LoginRequest></soap:Body></soap:Envelope>'

    print(requests.post("http://<Target address>/wsdl", data=payload, headers={"SOAPAction":'"ExecuteCommand"'}).content)
```



#### Path Traversal
- [ ] check for any resource load such as images files etc.
- [ ] use `../../` method or `....//....//....//` to retrieve resources.
- [ ] sometimes directly giving filename as parameter works.
- [ ] check multiple url encode on payload.
- [ ] if its an image use `%00.png` at the end of the file.

#### Business logic
- [ ] Add multiple items on cart an try sending negative values to all params, see if price decrease 

- [ ] Try to update to domain email of the site or company after logging in see if its possible and gets any extra functionality, eg: `admin functionality is available to company employees with company.com email address, after logging as normal user email update doesn't need verification and thus gets into admin funct.` 

 - [ ] see if the email string cut off as string size increase

- [ ] Find two different discount coupons in e-commerce functionality, use them one after another as when it says invalid use another repeat the process until price decreases.

- [ ] Brute force the params and find if any malpractice possible eg: brute forcing to certain value will change the whole price value  to negative  and adding another item on cart and adjusting quantity may tamper the total.

- [ ] try bypass the pass change functionality just by intercepting the req and completely removing the old pass parameter, now the functionality entirely rely on username, change it to privileged user.